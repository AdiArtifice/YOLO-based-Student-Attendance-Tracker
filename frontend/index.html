<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>YOLO Attendance Tracker</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      }
      body {
        margin: 0;
        padding: 0;
        background: #0f172a;
        color: #f8fafc;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      main {
        background: rgba(15, 23, 42, 0.85);
        border-radius: 18px;
        padding: 32px;
        width: min(720px, 90vw);
        box-shadow: 0 20px 45px rgba(15, 23, 42, 0.45);
      }
      h1 {
        margin-top: 0;
        font-size: clamp(2rem, 4vw, 2.75rem);
        letter-spacing: -0.03em;
      }
      p.lead {
        margin-bottom: 24px;
        color: #cbd5f5;
        font-size: 1.05rem;
      }
      form {
        display: grid;
        gap: 16px;
      }
      .file-input {
        border: 2px dashed rgba(148, 163, 184, 0.8);
        border-radius: 12px;
        padding: 20px;
        background: rgba(15, 23, 42, 0.35);
        text-align: center;
        transition: border-color 0.3s ease;
      }
      .file-input:hover {
        border-color: #38bdf8;
      }
      input[type="file"] {
        width: 100%;
        color: #cbd5f5;
      }
      button {
        background: linear-gradient(135deg, #38bdf8, #6366f1);
        border: none;
        border-radius: 999px;
        color: white;
        font-size: 1rem;
        font-weight: 600;
        padding: 14px 28px;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(99, 102, 241, 0.35);
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        box-shadow: none;
      }
      .status {
        margin-top: 12px;
        font-weight: 600;
      }
      .error {
        color: #f87171;
      }
      .success {
        color: #4ade80;
      }
      .grid {
        display: grid;
        gap: 20px;
        margin-top: 24px;
      }
      .panel {
        background: rgba(21, 32, 66, 0.8);
        padding: 20px;
        border-radius: 12px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th,
      td {
        padding: 10px 12px;
        text-align: left;
        border-bottom: 1px solid rgba(148, 163, 184, 0.25);
      }
      th {
        font-weight: 700;
        color: #94a3b8;
      }
      img {
        max-width: 100%;
        border-radius: 12px;
      }
      .attendance-note {
        margin-top: 12px;
        color: #cbd5f5;
        font-size: 0.95rem;
      }
      .preview-button {
        background: none;
        border: none;
        color: #38bdf8;
        cursor: pointer;
        font: inherit;
        padding: 0;
        text-decoration: underline;
      }
      .preview-button:hover,
      .preview-button:focus {
        color: #a855f7;
        outline: none;
      }
      .preview-button:disabled,
      .preview-button.preview-button--disabled {
        color: rgba(148, 163, 184, 0.6);
        cursor: not-allowed;
        text-decoration: none;
      }
      body.modal-open {
        overflow: hidden;
      }
      .modal {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.78);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 24px;
        z-index: 50;
      }
      .modal[hidden] {
        display: none;
      }
      .modal-content {
        position: relative;
        background: rgba(15, 23, 42, 0.95);
        border-radius: 16px;
        padding: 24px;
        max-width: min(420px, 90vw);
        width: 100%;
        box-shadow: 0 24px 60px rgba(15, 23, 42, 0.6);
        text-align: center;
      }
      .modal-content h3 {
        margin-top: 0;
        margin-bottom: 16px;
        font-size: 1.4rem;
      }
      .modal-content img {
        width: 100%;
        border-radius: 12px;
        margin-bottom: 16px;
        background: rgba(15, 23, 42, 0.6);
      }
      .modal-close {
        position: absolute;
        top: 12px;
        right: 12px;
        border: none;
        background: transparent;
        color: #94a3b8;
        font-size: 1.75rem;
        line-height: 1;
        cursor: pointer;
      }
      .modal-close:hover {
        color: #f8fafc;
      }
      .modal-details {
        color: #cbd5f5;
        font-size: 0.95rem;
      }
    </style>
  </head>
  <body>
    <main>
      <h1>YOLO-based Attendance</h1>
      <p class="lead">
        Upload a classroom photo to detect students and mark attendance automatically via Roboflow inference.
      </p>
      <form id="upload-form">
        <div class="file-input">
          <input id="file-input" type="file" accept="image/*" required />
          <p>PNG / JPG up to 10MB</p>
        </div>
        <button id="submit-btn" type="submit">Run Attendance</button>
        <span id="status" class="status"></span>
      </form>

      <div class="grid">
        <section class="panel">
          <h2>Attendance</h2>
          <table id="attendance-table" hidden>
            <thead>
              <tr>
                <th>Roll Number</th>
                <th>Status</th>
                <th>Confidence</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
          <p id="attendance-empty">No results yet.</p>
          <p class="attendance-note" id="attendance-instructions" hidden>
            Click a roll number to inspect the detected face crop and verify the student's identity.
          </p>
        </section>
        <section class="panel">
          <h2>Annotated Preview</h2>
          <img id="annotated-image" alt="Annotated classroom" hidden />
          <p id="image-empty">Upload an image to see the annotated result.</p>
        </section>
      </div>
    </main>

    <div
      id="crop-modal"
      class="modal"
      role="dialog"
      aria-modal="true"
      aria-labelledby="modal-title"
      hidden
    >
      <div class="modal-content">
        <button id="modal-close-btn" class="modal-close" type="button" aria-label="Close preview">
          &times;
        </button>
        <h3 id="modal-title">Student Preview</h3>
        <img id="modal-image" alt="Student crop" />
        <p id="modal-details" class="modal-details"></p>
      </div>
    </div>

    <script>
      // API base selection:
      // - In production/Azure: use relative paths so 443 is mapped to WEBSITES_PORT internally
      // - In local dev when opening the static file server (e.g., Live Server on :5500):
      //   direct API calls to the FastAPI backend on :8000 to avoid 405s from the static server
      const API_BASE = (window.location.port === '5500') ? 'http://localhost:8000' : '';
      const INSTRUCTION_DEFAULT =
        "Click a roll number to inspect the detected face crop and verify the student's identity.";
      const INSTRUCTION_EMPTY =
        'No face crops were returned by the workflow. Confirm your Roboflow dynamic crop block is enabled and runs after detection.';

      const form = document.getElementById('upload-form');
      const fileInput = document.getElementById('file-input');
      const statusEl = document.getElementById('status');
      const submitBtn = document.getElementById('submit-btn');
      const table = document.getElementById('attendance-table');
      const tableBody = table.querySelector('tbody');
      const attendanceEmpty = document.getElementById('attendance-empty');
      const attendanceInstructions = document.getElementById('attendance-instructions');
      const annotatedImg = document.getElementById('annotated-image');
      const imageEmpty = document.getElementById('image-empty');
      const modal = document.getElementById('crop-modal');
      const modalImage = document.getElementById('modal-image');
      const modalTitle = document.getElementById('modal-title');
      const modalDetails = document.getElementById('modal-details');
      const modalCloseBtn = document.getElementById('modal-close-btn');

      let latestCropMap = createEmptyCropMap();
  let currentAttendanceEntries = [];

      form.addEventListener('submit', async (event) => {
        event.preventDefault();
        if (!fileInput.files.length) {
          statusEl.textContent = 'Please choose an image.';
          statusEl.className = 'status error';
          return;
        }

        closeModal();

        const file = fileInput.files[0];
        const formData = new FormData();
        formData.append('file', file);

        statusEl.textContent = 'Processing...';
        statusEl.className = 'status';
        submitBtn.disabled = true;

        try {
          const response = await fetch(`${API_BASE}/api/upload`, {
            method: 'POST',
            body: formData,
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({ detail: 'Upload failed' }));
            throw new Error(errorData.detail || 'Upload failed');
          }

          const data = await response.json();
          latestCropMap = normaliseCropMap(data.crops);
          currentAttendanceEntries = Array.isArray(data.attendance) ? data.attendance : [];
          renderAttendance(currentAttendanceEntries, latestCropMap);

          if (data.annotated_image) {
            annotatedImg.src = data.annotated_image;
            annotatedImg.hidden = false;
            imageEmpty.hidden = true;
          } else {
            annotatedImg.hidden = true;
            annotatedImg.src = '';
            imageEmpty.hidden = false;
          }

          statusEl.textContent = data.message || 'Attendance processed.';
          statusEl.className = 'status success';
        } catch (err) {
          console.error(err);
          statusEl.textContent = err.message || 'Processing failed';
          statusEl.className = 'status error';
          latestCropMap = createEmptyCropMap();
          renderAttendance([], latestCropMap);
          annotatedImg.hidden = true;
          annotatedImg.src = '';
          imageEmpty.hidden = false;
        } finally {
          submitBtn.disabled = false;
        }
      });

      modalCloseBtn.addEventListener('click', closeModal);
      modal.addEventListener('click', (event) => {
        if (event.target === modal) {
          closeModal();
        }
      });
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && !modal.hidden) {
          closeModal();
        }
      });
      modalImage.addEventListener('error', () => {
        if (!modalDetails.textContent.includes('Crop unavailable')) {
          modalDetails.textContent = modalDetails.textContent
            ? `${modalDetails.textContent} • Crop unavailable`
            : 'Crop unavailable';
        }
      });

      function renderAttendance(entries, cropMap = createEmptyCropMap()) {
        tableBody.innerHTML = '';
        if (!entries.length) {
          table.hidden = true;
          attendanceEmpty.hidden = false;
          updateInstructions(0);
          return;
        }

        const fragment = document.createDocumentFragment();
        const fallbackQueue = Array.isArray(cropMap.fallback) ? [...cropMap.fallback] : [];
        let previewCount = 0;

        entries.forEach((entry, index) => {
          const resolvedCrop = resolveCrop(entry, cropMap, fallbackQueue);
          const row = document.createElement('tr');
          row.dataset.rowId = String(index);

          const rollCell = document.createElement('td');
          const rollViewBtn = document.createElement('button');
          rollViewBtn.type = 'button';
          rollViewBtn.className = 'preview-button';
          rollViewBtn.textContent = entry.roll_number;
          rollViewBtn.dataset.rollNumber = entry.roll_number ?? 'Unknown';
          rollViewBtn.dataset.predictionId = entry.prediction_id ?? '';
          rollViewBtn.dataset.confidence = typeof entry.confidence === 'number' ? entry.confidence : 0;

          if (resolvedCrop && resolvedCrop.image) {
            previewCount += 1;
            const preload = new Image();
            preload.src = resolvedCrop.image;
            rollViewBtn.classList.remove('preview-button--disabled');
            rollViewBtn.disabled = false;
            rollViewBtn.dataset.cropImage = resolvedCrop.image;
            rollViewBtn.dataset.cropLabel = resolvedCrop.label ?? entry.roll_number ?? 'Unknown';
            rollViewBtn.dataset.cropSource = resolvedCrop.source || entry.crop_source || '';
            if (resolvedCrop.prediction_id) {
              rollViewBtn.dataset.cropPredictionId = resolvedCrop.prediction_id;
            }
            const metadata = resolvedCrop.metadata || entry.crop_metadata || entry.metadata;
            if (metadata && typeof metadata === 'object') {
              try {
                rollViewBtn.dataset.cropMetadata = JSON.stringify(metadata);
              } catch (error) {
                delete rollViewBtn.dataset.cropMetadata;
              }
            }
            rollViewBtn.addEventListener('click', handlePreviewClick);
          } else {
            rollViewBtn.classList.add('preview-button--disabled');
            rollViewBtn.disabled = true;
          }

          const rollEditInput = document.createElement('input');
          rollEditInput.type = 'text';
          rollEditInput.value = entry.roll_number ?? '';
          rollEditInput.style.display = 'none';
          rollEditInput.setAttribute('aria-label', 'Edit roll number');

          rollCell.appendChild(rollViewBtn);
          rollCell.appendChild(rollEditInput);
          row.appendChild(rollCell);

          const statusCell = document.createElement('td');
          const statusViewSpan = document.createElement('span');
          statusViewSpan.textContent = entry.status;
          const statusEditSelect = createStatusSelect(entry.status);
          statusEditSelect.style.display = 'none';
          statusCell.appendChild(statusViewSpan);
          statusCell.appendChild(statusEditSelect);
          row.appendChild(statusCell);

          const confidenceCell = document.createElement('td');
          confidenceCell.textContent = (entry.confidence ?? 0).toFixed(2);
          row.appendChild(confidenceCell);

          // Actions cell for Edit/Save/Cancel
          const actionsCell = document.createElement('td');
          const editBtn = document.createElement('button');
          editBtn.type = 'button';
          editBtn.textContent = 'Edit';
          const saveBtn = document.createElement('button');
          saveBtn.type = 'button';
          saveBtn.textContent = 'Save';
          saveBtn.style.display = 'none';
          const cancelBtn = document.createElement('button');
          cancelBtn.type = 'button';
          cancelBtn.textContent = 'Cancel';
          cancelBtn.style.display = 'none';

          editBtn.addEventListener('click', () => enterEditMode(row, { rollViewBtn, rollEditInput, statusViewSpan, statusEditSelect, editBtn, saveBtn, cancelBtn }));
          saveBtn.addEventListener('click', () => saveRowUpdate(row, { rollViewBtn, rollEditInput, statusViewSpan, statusEditSelect, editBtn, saveBtn, cancelBtn }));
          cancelBtn.addEventListener('click', () => exitEditMode(row, { rollViewBtn, rollEditInput, statusViewSpan, statusEditSelect, editBtn, saveBtn, cancelBtn }, /*reset=*/true));

          actionsCell.appendChild(editBtn);
          actionsCell.appendChild(saveBtn);
          actionsCell.appendChild(cancelBtn);
          row.appendChild(actionsCell);

          fragment.appendChild(row);
        });

        tableBody.appendChild(fragment);
        table.hidden = false;
        attendanceEmpty.hidden = true;
        updateInstructions(previewCount, entries.length);
      }

      function createStatusSelect(current) {
        const select = document.createElement('select');
        const values = ['present', 'absent'];
        values.forEach((v) => {
          const opt = document.createElement('option');
          opt.value = v;
          opt.textContent = v;
          if ((current || '').toLowerCase() === v) {
            opt.selected = true;
          }
          select.appendChild(opt);
        });
        return select;
      }

      function enterEditMode(row, refs) {
        row.dataset.editing = '1';
        refs.rollViewBtn.style.display = 'none';
        refs.rollEditInput.style.display = '';
        refs.statusViewSpan.style.display = 'none';
        refs.statusEditSelect.style.display = '';
        refs.editBtn.style.display = 'none';
        refs.saveBtn.style.display = '';
        refs.cancelBtn.style.display = '';
      }

      function exitEditMode(row, refs, reset = false) {
        if (reset) {
          // restore inputs from current view text
          refs.rollEditInput.value = refs.rollViewBtn.textContent || '';
          const desired = (refs.statusViewSpan.textContent || '').toLowerCase();
          Array.from(refs.statusEditSelect.options).forEach((opt) => {
            opt.selected = (opt.value === desired);
          });
        }
        delete row.dataset.editing;
        refs.rollViewBtn.style.display = '';
        refs.rollEditInput.style.display = 'none';
        refs.statusViewSpan.style.display = '';
        refs.statusEditSelect.style.display = 'none';
        refs.editBtn.style.display = '';
        refs.saveBtn.style.display = 'none';
        refs.cancelBtn.style.display = 'none';
      }

      async function saveRowUpdate(row, refs) {
        const rowId = Number.parseInt(row.dataset.rowId || '-1', 10);
        const newRoll = refs.rollEditInput.value.trim();
        const newStatus = (refs.statusEditSelect.value || '').toLowerCase();
        // Optimistic UI disable
        refs.saveBtn.disabled = true;
        refs.cancelBtn.disabled = true;
        try {
          const resp = await fetch(`${API_BASE}/api/attendance/update`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ row_id: rowId, roll_number: newRoll, status: newStatus }),
          });
          const payload = await resp.json().catch(() => ({ ok: false, error: 'Invalid server response' }));
          if (!resp.ok || !payload.ok) {
            throw new Error(payload.error || 'Update failed');
          }
          const updated = payload.updated || {};
          // Update UI from server echo
          refs.rollViewBtn.textContent = updated.roll_number || newRoll || '';
          refs.rollViewBtn.dataset.rollNumber = updated.roll_number || newRoll || '';
          refs.statusViewSpan.textContent = updated.status || newStatus || '';
          exitEditMode(row, refs, /*reset=*/false);
        } catch (e) {
          console.error(e);
          alert(e.message || 'Update failed');
        } finally {
          refs.saveBtn.disabled = false;
          refs.cancelBtn.disabled = false;
        }
      }

      function resolveCrop(entry, cropMap, fallbackQueue) {
        if (!entry) {
          return null;
        }
        if (entry.crop_image) {
          return {
            image: entry.crop_image,
            label: entry.crop_label || entry.roll_number,
            metadata: entry.crop_metadata || entry.metadata || null,
            prediction_id: entry.crop_prediction_id || entry.prediction_id || null,
            source: entry.crop_source || 'attendance',
          };
        }

        const byPrediction = isPlainObject(cropMap.by_prediction_id) ? cropMap.by_prediction_id : {};
        const byLabel = isPlainObject(cropMap.by_label) ? cropMap.by_label : {};
        const byLabelLower = isPlainObject(cropMap.by_label_lower) ? cropMap.by_label_lower : {};

        const predictionId = entry.prediction_id ?? entry.crop_prediction_id ?? entry?.metadata?.prediction_id;
        if (predictionId !== undefined && predictionId !== null) {
          const key = String(predictionId).trim();
          if (key && byPrediction[key]) {
            const payload = byPrediction[key];
            return {
              ...payload,
              prediction_id: payload.prediction_id || key,
              source: payload.source || 'prediction_id',
            };
          }
        }

        const rollNumber = entry.roll_number;
        if (typeof rollNumber === 'string') {
          const direct = byLabel[rollNumber];
          if (direct) {
            return {
              ...direct,
              prediction_id: direct.prediction_id || predictionId || null,
              source: direct.source || 'label',
            };
          }
          const lower = rollNumber.toLowerCase();
          if (byLabelLower[lower]) {
            const payload = byLabelLower[lower];
            return {
              ...payload,
              prediction_id: payload.prediction_id || predictionId || null,
              source: payload.source || 'label',
            };
          }
        }

        if (fallbackQueue && fallbackQueue.length) {
          const fallback = fallbackQueue.shift();
          if (fallback && fallback.image) {
            return {
              ...fallback,
              prediction_id: fallback.prediction_id || predictionId || null,
              source: fallback.source || 'fallback',
            };
          }
        }

        return null;
      }

      function handlePreviewClick(event) {
        const button = event.currentTarget;
        const cropImage = button.dataset.cropImage;
        if (!cropImage) {
          return;
        }
        const rollNumber = button.dataset.rollNumber || 'Unknown';
        const cropLabel = button.dataset.cropLabel || rollNumber;
        const confidence = Number.parseFloat(button.dataset.confidence ?? '0');
        const source = button.dataset.cropSource || '';
        let metadata = {};
        if (button.dataset.cropMetadata) {
          try {
            const parsed = JSON.parse(button.dataset.cropMetadata);
            if (parsed && typeof parsed === 'object') {
              metadata = parsed;
            }
          } catch (error) {
            metadata = {};
          }
        }
        openModal({
          rollNumber,
          cropLabel,
          cropImage,
          confidence,
          metadata,
          source,
        });
      }

      function openModal({ rollNumber, cropLabel, cropImage, confidence, metadata = {}, source = '' }) {
        modalTitle.textContent = cropLabel || rollNumber || 'Student Preview';
        modalImage.src = cropImage;
        modalImage.alt = `Crop for ${rollNumber || 'student'}`;
        const parts = [];
        if (rollNumber) parts.push(`Roll Number: ${rollNumber}`);
        if (Number.isFinite(confidence)) {
          parts.push(`Confidence ${(confidence * 100).toFixed(1)}%`);
        }
        if (metadata && typeof metadata === 'object') {
          if (metadata.roll_number && metadata.roll_number !== rollNumber) {
            parts.push(`Workflow: ${metadata.roll_number}`);
          } else if (metadata.label && metadata.label !== cropLabel) {
            parts.push(`Workflow: ${metadata.label}`);
          }
        }
        if (source) {
          parts.push(`Source: ${formatCropSource(source)}`);
        }
        modalDetails.textContent = parts.join(' • ');
        modal.hidden = false;
        document.body.classList.add('modal-open');
      }

      function closeModal() {
        if (modal.hidden) {
          return;
        }
        modal.hidden = true;
        modalImage.src = '';
        modalTitle.textContent = '';
        modalDetails.textContent = '';
        document.body.classList.remove('modal-open');
      }

      function updateInstructions(previewCount, total = 0) {
        if (!attendanceInstructions) {
          return;
        }
        if (!total) {
          attendanceInstructions.hidden = true;
          return;
        }
        if (previewCount > 0) {
          attendanceInstructions.hidden = false;
          attendanceInstructions.textContent = INSTRUCTION_DEFAULT;
        } else {
          attendanceInstructions.hidden = false;
          attendanceInstructions.textContent = INSTRUCTION_EMPTY;
        }
      }

      function normaliseCropMap(raw) {
        if (!isPlainObject(raw)) {
          return createEmptyCropMap();
        }
        const byPrediction = isPlainObject(raw.by_prediction_id) ? raw.by_prediction_id : {};
        const byLabel = isPlainObject(raw.by_label) ? raw.by_label : {};
        const byLabelLower = {};
        Object.keys(byLabel).forEach((key) => {
          if (typeof key === 'string') {
            byLabelLower[key.toLowerCase()] = byLabel[key];
          }
        });
        const fallback = Array.isArray(raw.fallback)
          ? raw.fallback.filter((item) => isPlainObject(item) && item.image)
          : [];
        return {
          by_prediction_id: byPrediction,
          by_label: byLabel,
          by_label_lower: byLabelLower,
          fallback,
        };
      }

      function createEmptyCropMap() {
        return { by_prediction_id: {}, by_label: {}, by_label_lower: {}, fallback: [] };
      }

      function isPlainObject(value) {
        return value !== null && typeof value === 'object' && !Array.isArray(value);
      }

      function formatCropSource(source) {
        const lookup = {
          attendance: 'Attached to attendance entry',
          'prediction_id': 'Matched by prediction',
          prediction: 'Matched by prediction',
          label: 'Matched by label',
          fallback: 'Fallback crop',
        };
        return lookup[source] || source;
      }
    </script>
  </body>
</html>
